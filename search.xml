<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>effiective C++学习笔记（一）</title>
    <url>/2021/07/13/effiective-C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近开始学习侯捷老师翻译的《effiective C++》一书，但书本上的知识如果不经常用，很快就会忘记。所以开个专栏，把从书中看到的对自己有用的知识点都记下来，希望能坚持下去。不要太着急，一步一脚印的前进。勿以浮沙筑高台，望知其所以然而非只知其然。</p>
<h1 id="导读篇"><a href="#导读篇" class="headerlink" title="导读篇"></a>导读篇</h1><h2 id="0-1-初始化与explicit关键字"><a href="#0-1-初始化与explicit关键字" class="headerlink" title="0-1 初始化与explicit关键字"></a>0-1 初始化与explicit关键字</h2><p>下面一段代码定义了A、B、C三个类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  A();	<span class="comment">// 默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">bool</span> b = <span class="literal">true</span>)</span></span>; 	<span class="comment">// default构造函数 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> x)</span></span>;		<span class="comment">// 不是default构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​        可以看到，上述的class B 和 C的构造函数都被声明为 <strong>explicit</strong>。<em>被声明为 <strong>explicit</strong>的构造函数不能被用来执行隐式类型转换（<strong>implicit type conversions</strong>）,但他们仍可被用来进行执行显示类型转换（<strong>explicit type conversions</strong>）</em>。什么意思呢，书中根据上面定义的ABC三个类，给出了如下的初始化例子来说明带<strong>explicit</strong>的构造函数的好处。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(B bObject)</span></span>;	<span class="comment">// 函数，接受一个类型为B的对象</span></span><br><span class="line"></span><br><span class="line">B bObj1;									<span class="comment">// 一个类型为B的对象</span></span><br><span class="line">doSomething(bObj1);				<span class="comment">// 没问题，传递一个B给doSomething函数</span></span><br><span class="line">B bObj2;									<span class="comment">// 没问题，根据 int 28建立一个B</span></span><br><span class="line"></span><br><span class="line">doSomething(<span class="number">28</span>);				  <span class="comment">// 错误，不能将28隐是的转换为B</span></span><br><span class="line"></span><br><span class="line">doSomething(B(<span class="number">28</span>));				<span class="comment">// 正确，使用B构造函数将int显示转换为B</span></span><br></pre></td></tr></table></figure>
<p>​        可以看出，被声明为<strong>explicit</strong>的构造函数禁止编译器执行非预期的类型转换。</p>
<h3 id="建议：除非有一个好理由允许构造函数被用于隐式的类型转换，否则建议声明为explicit"><a href="#建议：除非有一个好理由允许构造函数被用于隐式的类型转换，否则建议声明为explicit" class="headerlink" title="建议：除非有一个好理由允许构造函数被用于隐式的类型转换，否则建议声明为explicit"></a>建议：除非有一个好理由允许构造函数被用于隐式的类型转换，否则建议声明为explicit</h3><h2 id="0-2-copy构造函数与copy-assignment操作符"><a href="#0-2-copy构造函数与copy-assignment操作符" class="headerlink" title="0-2 copy构造函数与copy assignment操作符"></a>0-2 copy构造函数与copy assignment操作符</h2><p>​    平时在使用copy构造函数和 = 操作符时，我常常不会刻意的去想到底此时使用的是copy构造函数还是 = 操作符。那两者有什么区别呢？在《effiective C++》书中，对两者的描述是 <em>copy构造函数被用来<strong>“以同型对象初始化自我对象”</strong>， 而copy assignment 操作符被用来<strong>“从另一个同型对象中拷贝其值到自我对象”</strong></em>。换言之，前者应用于<strong>新对象被定义时</strong>的拷贝，后者用于<strong>两个已有对象</strong>的赋值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  TestA();									<span class="comment">// default构造函数</span></span><br><span class="line">  TestA(<span class="keyword">const</span> TestA&amp; ta);		<span class="comment">// copy构造函数</span></span><br><span class="line">  TestA&amp; operation= (<span class="keyword">const</span> TestA&amp; ta);	<span class="comment">// copy assignment操作符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TestA ta1;</span><br><span class="line"><span class="function">TestA <span class="title">ta2</span><span class="params">(ta1)</span></span>;				<span class="comment">// 有新对象ta2创建，调用copy构造函数</span></span><br><span class="line">TestA ta3 = ta1;			<span class="comment">// 有新对象ta3创建，调用copy构造函数</span></span><br><span class="line">ta3 = ta2;						<span class="comment">// 没有新对象创建，调用copy assignment操作符进行赋值操作</span></span><br></pre></td></tr></table></figure>
<p>​        值得注意的是，操作 “TestA ta3 = ta1; ” 也是执行的 copy构造函数操作而不是用copy assignment操作符进行赋值，因为此时创建了新对象ta3。对象创建与构造函数挂钩，有新对象创建就会调用构造函数，没有新对象被创建时使用 = 操作会调用copy assignment操作符进行赋值操作。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>详解YUV420格式</title>
    <url>/2020/04/08/%E8%AF%A6%E8%A7%A3YUV420%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<p>原文地址：<a href="http://www.cnblogs.com/azraelly/achive/2013/01/01/2841269.html" target="_blank" rel="noopener">http://www.cnblogs.com/azraelly/achive/2013/01/01/2841269.html</a></p>
<ol>
<li>YUV简介</li>
</ol>
<p>YUV定义：分为三个分量，其中Y表示亮度，也即灰度值；U、V表示色度，用于指定像素的颜色。</p>
<p>YUV格式：分为 planar（平面） 和 packed（打包）两种格式。</p>
<p>对于planar的YUV格式，使用三个数组分开存放YUV分量，先连续存储所有的像素点的Y，紧接着存储着所有像素点的U，随后是所有像素点的V，即按序存储 Y -&gt; U -&gt; V。</p>
<p>对于packed的YUV格式，将YUV分量存放在同一个数组中，通常是几个相邻的像素组成一个宏像素，每个像素点Y，U，V是连续交叉存储的。</p>
]]></content>
      <tags>
        <tag>视音频技术</tag>
      </tags>
  </entry>
  <entry>
    <title>SVN cleanup与sqlite3</title>
    <url>/2020/03/01/SVN-cleanup%E4%B8%8Esqlite3/</url>
    <content><![CDATA[<p>之前从公司拉svn代码下来的时候，老是</p>
]]></content>
  </entry>
  <entry>
    <title>STL六大组件功能与应用</title>
    <url>/2020/02/27/STL%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6%E5%8A%9F%E8%83%BD%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>前言，最近想沉下来，学习一下常见容器的底层实现方法，那肯定是不能错过《STL源码剖析》这本经典的书了。我打算在我的博客新建一个STL栏，用来记录从这本书里学到的内容，便于以后温故时习之。</p>
<h2 id="STL六大组件功能与应用介绍"><a href="#STL六大组件功能与应用介绍" class="headerlink" title="STL六大组件功能与应用介绍"></a>STL六大组件功能与应用介绍</h2><p>STL提供了六大组件，下面将简单介绍一下这六大组件是什么。（PS：主要是书中前言对他们的概述，后期学的更深入了后会再回来补充）</p>
<ol>
<li><strong>容器（containers）</strong>：各种数据结构，如<code>vector</code>，<code>list</code>，<code>deque</code>，<code>set</code>，<code>map</code>用来存放数据。也可以主要分为两大类：序列容器（sequence container）和关联容器（associative container）。从实现角度来看，STL容器是一种<code>class template</code>。</li>
<li><strong>算法（algorithms）</strong>：各种常用的算法如 <code>sort</code>，<code>search</code>，<code>copy</code>，<code>erase</code>···。从实现角度来看，STL算法是一种<code>function template</code>。</li>
<li><strong>迭代器（iterator）：</strong>扮演容器与算法之间的胶合剂，是所谓的泛型指针，详见第三章。共有五种类型，以及其它衍生变化。从实现角度来看，迭代器是一种将 <code>operator*</code>，<code>operator-&gt;</code>，<code>operator++</code>，<code>operator--</code>等指针相关操作予以重载的<code>class template</code>。所有的STL容器都附带有自己的专属迭代器。</li>
<li><strong>仿函数（functors）：</strong>行为类似函数，可作为算法的某种策略（policy）。从实现的角度来看，仿函数是一种重载了<code>operator()</code>的<code>class</code>或<code>class template</code>。</li>
<li><strong>配接器（adapters）</strong>：一种用来修饰容器（containers）或仿函数（functors）或迭代器（iterators）接口的东西。例如，STL提供的<code>queue</code>和<code>stack</code>，虽然看似容器，其实只能算是一种容器配接器，因为它们底部完全借助<code>deque</code>，所有操作都由底层的deque供应。改变<code>functor</code>接口者，称为<code>functor adapter</code>；改变<code>containers</code>接口者，称为<code>container adapter</code>；改变<code>iterator</code>接口者，称为<code>iterator adapter</code>。</li>
<li><strong>配置器（allocators）：</strong>负责空间配置与管理。从实现角度来看，配置器是实现了一个动态空间配置、空间管理、空间释放的<code>class template</code>。</li>
</ol>
<p>图1-1是STL六大组件的交互图</p>
<p><img src="/2020/02/27/STL六大组件功能与应用/STL六大组件之间的交互关系.png" alt="STL六大组件之间的交互关系"></p>
<pre><code>其中，Container 通过 Allocator 取得数据存储空间，Algorithm 通过 Iterator 存取 Container的内容，Functor 可以协助 Algorithm 完成不同的策略变化，Adapter可以修饰或套接 Functor。
</code></pre>]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>pkg-config 详解</title>
    <url>/2020/02/26/pkg-config-%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="pig-config-详解"><a href="#pig-config-详解" class="headerlink" title="pig-config 详解"></a>pig-config 详解</h2><p>转载自：<a href="https://blog.csdn.net/newchenxf/article/details/51750239" target="_blank" rel="noopener">https://blog.csdn.net/newchenxf/article/details/51750239</a></p>
<p>最近在学习libuv，mac上安装了libuv后发现怎么用它是个难题。因为本人是打算用vscode来写一写C++的一些小demo的。然后发现一篇在mac上配置opencv并用vscode调试C++的博文，受到了启发，然后发现了pkg-config这个好宝贝。现在转载一些pkg-config的用法，方便以后查阅。</p>
<ol>
<li><p><strong>什么是pkg-config？</strong></p>
<p>pkg-config 是一个linux下的命令，用于获得某一个库/模块的所有编译相关的信息</p>
</li>
<li><p><strong>为什么要有pkg-config?</strong></p>
<p>   <code>pkg-config [Your-LIB] --libs --cflags</code>可以得到你想要的lib库的头文件和库信息</p>
</li>
<li><p><strong>pkg-config的信息从哪里来？</strong></p>
<p> 有两种路径：</p>
<p> 1） 取系统的 <code>/usr/lib</code>下的所有<code>*.pc</code>文件</p>
<p> 2）<code>PKG_CONFIG_PATH</code>环境变量所指向的路径下的所有 *.pc文件</p>
<p> 这些pc文件什么时候有的？都是在你安装某个库/模块的的时候添加的。</p>
</li>
<li><p><strong>pkg-config -help查看命令参数</strong></p>
<p> 1）<code>pkg-config [NAME] -cflags</code> 查看头文件信息</p>
<p> 2）<code>pkg-config [NAME] -libs</code> 查看库信息</p>
<p> 3）<code>pkg-config --list-all</code> 查看pkg-config的所有模块信息</p>
</li>
<li><p><strong>如何添加自己的pc文件</strong></p>
<p> 有两种方式</p>
<p> 1）把你的pc文件，直接放到<code>/usr/lib/...</code>默认路径下</p>
<p> 2）把你的pc文件的路径写到 <code>PKG_CONFIG_PATH</code>环境变量里。</p>
<p> 比如你可以在<code>/etc/.bashrc</code> 或者 <code>/home/Carrie/.bashrc</code>的文件末尾添加</p>
<p>  <code>PKG_CONFIG_PATH = $PKG_CONFIG_PATH:/home/Carrie/ffmpeg_build/lib/pkgconfig</code></p>
<p>  <code>export PKG_CONFIG_PATH</code></p>
<p> 那么，pkg-config就会到/home/Carrie/ffmpeg_build/lib/pkgconfig下寻找 *.pc文件</p>
</li>
<li><p><strong>如何写自己的pkg-config的pc文件</strong></p>
<p>先提一下pc文件的所有参数：</p>
<p><code>Name</code>: 该模块的的名字，比如你的pc名字是 xxx.pc，那么名字最好也是 xxx。</p>
<p><code>Description</code>:模块的简单描述。上文pkg-config –list-all 命令出来的结果，每个名字后面就是description。</p>
<p><code>URL</code>: 用户可以通过该URL获得更多信息，或者下载信息。也是辅助的，可要可不要。</p>
<p><code>Version</code>：版本号。</p>
<p><code>Requires</code>:该模块是否依赖于其他模块。一般没有。</p>
<p><code>Requires.private</code>:该模块是否依赖于其他模块。并且还不需要第三方知道的。一般也没有。</p>
<p><code>Confilcts</code>:有没有和别的模块冲突，常用于版本冲突。比如，Conflicts: bar &lt; 1.2.3，表示和 bar模块的1.2.3以下的版本有冲突。</p>
<p><code>Cflags</code>: 这个就很重要了，pkg-config的参数-cflags就指向这里。<strong>主要用于写本模块的头文件的路径。</strong></p>
<p><code>Libs</code>:也很重要，pkg-config的参数-libs就指向这里。主要用于写本模块的库/依赖库的路径。</p>
<p><code>Libs.private</code>：本模块依赖的库，但不需要第三方知道。</p>
<p>其实必须写的有五个：<strong>Name, Description, Version, Cflags, Libs</strong>。</p>
<p>这里列举两个例子，一个动态库的，一个静态库的。</p>
<h3 id="eg1-动态库的pc文件"><a href="#eg1-动态库的pc文件" class="headerlink" title="eg1 动态库的pc文件"></a>eg1 动态库的pc文件</h3><p>假设我写了libfoo.so，我的库将会被安装到/usr/local/lib/，头文件会放到/usr/local/include/foo。那么，pc文件可以这么写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">prefix=/usr/local</span><br><span class="line">exec_prefix=$&#123;prefix&#125;</span><br><span class="line">includedir=$&#123;prefix&#125;/include</span><br><span class="line">libdir=$&#123;exec_prefix&#125;/lib</span><br><span class="line"></span><br><span class="line">Name:foo</span><br><span class="line">Description: The foo library</span><br><span class="line">Version:1.0.0</span><br><span class="line">Cflags:-I$&#123;includedir&#125;/foo</span><br><span class="line">Libs:-L$&#123;libdir&#125; -lfoo</span><br></pre></td></tr></table></figure>
<h3 id="eg2静态库的pc文件"><a href="#eg2静态库的pc文件" class="headerlink" title="eg2静态库的pc文件"></a>eg2静态库的pc文件</h3><p>静态库链接动态库时，如何使用该静态库，如果我有个静态库libXXX.a，它依赖了很多其他的动态库libAA.so, libBB.so，那么第三方程序DD.c要使用libXXX.a时，编译时还得链接libAA.so，libBB.so。如何让第三方程序，可以不用操心我这个libXXX.a到底依赖了什么？很简单，就是我的libXXX.a写一个pc文件。</p>
<p>这里原作者是写了一个他使用ffmpeg的例子。我打算等我先整清楚libuv怎么配置的，再回来附上libuv的pc文件。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake教程搬运</title>
    <url>/2020/02/25/CMake%E6%95%99%E7%A8%8B%E6%90%AC%E8%BF%90/</url>
    <content><![CDATA[<p>参考文章：<a href="https://blog.csdn.net/zhuiyunzhugang/article/details/88142908" target="_blank" rel="noopener">https://blog.csdn.net/zhuiyunzhugang/article/details/88142908</a></p>
<h2 id="什么是CMake"><a href="#什么是CMake" class="headerlink" title="什么是CMake"></a>什么是CMake</h2><p>你也许听过好几种Make工具，例如<code>GUN Make</code>, QT的<code>qmake</code>,微软的<code>MS nmake</code>等等。这些make工具遵循着不同的规范和标准，所执行的makefile格式也不同。这就带来一个问题，如果我们的软件想要跨平台，为了保证它在各个平台上的正确编译，必须重新为每种标准写一次Makefile，这将是一件让人抓狂的工作。</p>
<p>CMake就是为解决上面问题所设计的工具，它允许开发者编写一种平台无关的CMakeList.txt文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化Makefile和工程文件，从而做到 “Write once, run everywhere”。</p>
<p>在 linux 平台下使用CMake 生成 Makefile 并编译的流程如下：</p>
<ol>
<li>编写CMake配置文件CMakeLists.txt。</li>
<li>执行命令 <code>cmake PATH</code>或者<code>ccmake PATH</code>生成 <code>Makefile 1 1ccmake</code>。其中，PATH是CMakeLists.txt所在的目录</li>
<li>使用<code>make</code>命令进行编译</li>
</ol>
<h2 id="入门案例：单个源文件"><a href="#入门案例：单个源文件" class="headerlink" title="入门案例：单个源文件"></a>入门案例：单个源文件</h2><p>对单个的一个源文件，我们只需要写几行代码就可以了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp 文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello CMake!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	  printHello();</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写CMakeLists.txt</p>
<p>首先编写CMakeLists.txt文件，并保存在与<code>main.cpp</code>源文件同个目录下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span>(Demo1)</span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo main.cpp)</span><br></pre></td></tr></table></figure>
<p>CMakeLists.txt的语法比较简单，由命令、注释和空格组成，其中命令是不区分大小写的。符号<code>#</code>后面的内容被认为是注释。命令由<strong>命令名称、小括号和参数</strong>组成，<strong>参数之间使用空格</strong>进行间隔。</p>
<p>对于上面的CMakeLists.txt文件，依次出现了几个命令：</p>
<ol>
<li><code>cmake_minimum_required</code>:指定运行此配置文件所需的CMake的最低版本；</li>
<li><code>project</code>:参数值是Demo1，该命令表示项目的名称是Demo1。</li>
<li><code>add_executable</code>: 将名为 main.cpp 的源文件编译成一个名称为 Demo 的可执行文件。</li>
</ol>
<p>编译项目</p>
<p>之后在<strong>当前目录</strong>执行 <code>cmake.</code>，得到 Makefile后再使用 <code>make</code>命令编译得到Demo1可执行文件。</p>
<h2 id="多个源文件"><a href="#多个源文件" class="headerlink" title="多个源文件"></a>多个源文件</h2><h3 id="同一目录，多个源文件"><a href="#同一目录，多个源文件" class="headerlink" title="同一目录，多个源文件"></a>同一目录，多个源文件</h3><p>上面的例子只有单个源文件。现在假如把<code>printHello</code>函数单独写进一个名为HelloFunctions.cpp的源文件里，是的这个工程变为如下形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./Demo2</span><br><span class="line">|</span><br><span class="line">+--- main.cpp</span><br><span class="line">|</span><br><span class="line">+--- HelloFunctions.cpp</span><br><span class="line">|</span><br><span class="line">+--- HelloFunctions.h</span><br></pre></td></tr></table></figure>
<p>这个时候，CMakeLists.txt可以改为如下形式：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span>(Demo2)</span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo main.cpp HelloFunctions.cpp)</span><br></pre></td></tr></table></figure>
<p>唯一的改动只是在<code>add_executable</code>命令中增加了一个 HelloFunctions.cpp 源文件。这样写当然没有什么问题，但是如果源文件很多，把所有源文件的名字都加进去将是一件烦人的工作。更省事的方法是使用 <code>aux_source_directory</code>命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。其语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(&lt;dir&gt;&lt;variable&gt;)</span><br></pre></td></tr></table></figure>
<p>因此，可以修改 CMakeLists.txt如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line">cmake_minimum_reuquired(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span>(Demo2)</span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>这样，CMake会将当前目录所有源文件的文件名赋值给变量 DIR_SRCS，再指示给变量 DIR_SRCS中的源文件需要编译成一个名称为Demo的可执行文件</p>
<h3 id="多个目录，多个源文件"><a href="#多个目录，多个源文件" class="headerlink" title="多个目录，多个源文件"></a>多个目录，多个源文件</h3><p>现在进一步将HelloFunctions.h和HelloFunctions.cpp文件移动到 Hello 目录下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./Demo3</span><br><span class="line">|</span><br><span class="line">+--- main.cpp</span><br><span class="line">|</span><br><span class="line">+--- Hello/</span><br><span class="line">|</span><br><span class="line">+--- HelloFunctions.cpp</span><br><span class="line">|</span><br><span class="line">+--- HelloFunctions.h</span><br></pre></td></tr></table></figure>
<p>对于这种情况，需要分别在项目根目录Demo3 和 Hello目录里各编写一个CMakeLists.txt文件 。为了方便，我们可以先将 math 目录里的文件编译成静态库再由main函数调用。</p>
<p>根目录中的CMakeLists.txt：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号的要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span>(Demo4)</span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"><span class="comment"># 添加 math子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="keyword">math</span>)</span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo main.cpp)</span><br><span class="line"><span class="comment"># 添加链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Demo HelloFunctions)</span><br></pre></td></tr></table></figure>
<p>该文件添加了下面的内容：第三行 ，使用命令 <code>add_subdirectory</code>指明本项目包含一个子目录 Hello， 这样 Hello 目录下的 CMakeLists.txt 文件和源代码也会被处理。第 6 行， 使用命令 <code>target_link_libraries</code>指明可执行文件 main 需要连接一个名为 HelloFunctions的链接库。</p>
<p>子目录中的CMakeLists.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查找当前目录下的所有文件</span><br><span class="line"># 并将名称保存到 DIR_LIB_SRCS 变量</span><br><span class="line">aux_source_directory(. DIR_LIB_SRCS)</span><br><span class="line"># 生成链接库</span><br><span class="line">add_library(MathFunctions $&#123;DIR_LIB_SRCS&#125;)</span><br></pre></td></tr></table></figure>
<p>在该文件中使用命令 add_library 将 src 目录中的源文件编译为静态链接库</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>利用sleep()实现定时抓取</title>
    <url>/2020/01/10/%E5%88%A9%E7%94%A8sleep-%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E6%8A%93%E5%8F%96/</url>
    <content><![CDATA[<p><strong>最近工作要求用实现一个功能线程，要求定时从Redis里读取数据并处理。正好学习下线程编程。</strong><br>直接上代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*====================</span></span><br><span class="line"><span class="comment">    Redis数据处理类</span></span><br><span class="line"><span class="comment">=====================*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CReadRedis</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CReadRedis()</span><br><span class="line">    ~CReadRedis();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __<span class="function">stdcall <span class="title">ReadRedisThreadProc</span><span class="params">( <span class="keyword">void</span> *lp )</span></span>; <span class="comment">//读数据线程</span></span><br><span class="line">    <span class="keyword">void</span>* m_hThread;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> m_Exit;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; m_dataInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ConnectRedis</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ReleaseRedis</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*====================</span></span><br><span class="line"><span class="comment">读Redis线程</span></span><br><span class="line"><span class="comment">=====================*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadRedisThreadProc</span><span class="params">(<span class="keyword">void</span>* lp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CReadRedis *pThis = (CReadRedis* )lp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pThis)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            wait(<span class="number">1000</span>, m_bExit);  <span class="comment">// 每隔1s刷一次数据</span></span><br><span class="line">            <span class="keyword">if</span> (m_bExit)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//定时去获取Redis里的线程</span></span><br><span class="line">            <span class="comment">//·········</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>利用boost.asio实现get和post请求</title>
    <url>/2019/12/26/%E5%88%A9%E7%94%A8boost-asio%E5%AE%9E%E7%8E%B0get%E5%92%8Cpost%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<p>本文转载自 <a href="http://blog.csdn.net/duzixi" target="_blank" rel="noopener">http://blog.csdn.net/duzixi</a></p>
<p>学习使用boost.asio提供的socket网络连接，返回的是std::string类型<br>话不多说直接上源码</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><h3 id="NetworkRequest-h"><a href="#NetworkRequest-h" class="headerlink" title="NetworkRequest.h"></a>NetworkRequest.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  NetworkRequest.h</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"json.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"boost/asio.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Get 请求</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">GetRequest</span><span class="params">(<span class="keyword">char</span>* host, <span class="keyword">char</span>* path)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">GetRequest</span><span class="params">(<span class="built_in">string</span> url)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Post请求</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">PostRequest</span><span class="params">(<span class="keyword">char</span>* host, <span class="keyword">char</span>*path, <span class="built_in">string</span> form)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="NetworkRequest-cpp"><a href="#NetworkRequest-cpp" class="headerlink" title="NetworkRequest.cpp"></a>NetworkRequest.cpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  NetworkRequest.cpp</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"NetworkRequest.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> boost::asio::ip::tcp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Post请求</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">PostRequest</span><span class="params">(<span class="keyword">char</span>* host, <span class="keyword">char</span>* path, <span class="built_in">string</span> form)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> length = form.length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明Asio基础： io_service (任务调度机)</span></span><br><span class="line">    boost::asio::io_service io_service;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务器终端列表</span></span><br><span class="line">    tcp::<span class="function">resolver <span class="title">resolver</span><span class="params">(io_service)</span></span>;</span><br><span class="line">    tcp::resolver::<span class="function">query <span class="title">query</span><span class="params">(host, <span class="string">"http"</span>)</span></span>;</span><br><span class="line">    tcp::resolver::iterator iter = resolver.resolve(query);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试链接每一个终端，直到建立socket链接</span></span><br><span class="line">    tcp::<span class="function">socket <span class="title">socket</span><span class="params">(io_service)</span></span>;</span><br><span class="line">    boost::asio::connect(socket, iter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建网络请求头</span></span><br><span class="line">    <span class="comment">// 指定 "Connection: close" 在获取应答后断开连接，确保获取文件全部数据</span></span><br><span class="line">    boost::asio::streambuf request;</span><br><span class="line">    <span class="function">ostream <span class="title">request_stream</span><span class="params">(&amp;requeset)</span></span>;</span><br><span class="line">    request_stream &lt;&lt; <span class="string">"Post"</span> &lt;&lt; path &lt;&lt; <span class="string">" HTTP/1.1\r\n"</span>;</span><br><span class="line">    request_stream &lt;&lt; <span class="string">"Host:"</span> &lt;&lt; host &lt;&lt; <span class="string">"\r\n"</span>;\</span><br><span class="line">    request_stream &lt;&lt; <span class="string">"Accept: */*\r\n"</span>;</span><br><span class="line">    request_stream &lt;&lt; <span class="string">"Content-Type:application/x-www-for,-urlencoded\r\n"</span>;</span><br><span class="line">    request_stream &lt;&lt; <span class="string">"Content-Length: "</span> &lt;&lt; length &lt;&lt; <span class="string">"\r\n"</span>;</span><br><span class="line">    request_stream &lt;&lt; <span class="string">"Connection: close\r\n\r\n"</span>;  <span class="comment">//注意这里是两个空行</span></span><br><span class="line">    request_stream &lt;&lt; form; <span class="comment">//Post 发送的数据本身不包含多余空行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送请求</span></span><br><span class="line">    boost::asio::write(socket, request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取应答状态，应答缓冲流 streambuf 会自动增长至完整的行</span></span><br><span class="line">    <span class="comment">// 该增长可以在构造缓冲流时通过设置最大值限制</span></span><br><span class="line">    boost::asio::streambuf response;</span><br><span class="line">    boost::asio::read_until(socket, response, <span class="string">"\r\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查应答是否ok</span></span><br><span class="line">    <span class="function">istream <span class="title">response_stream</span><span class="params">(&amp;response)</span></span>; <span class="comment">//  应答流</span></span><br><span class="line">    <span class="built_in">string</span> http_version;</span><br><span class="line">    response_stream &gt;&gt; http_version;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> status_code;</span><br><span class="line">    response_stream &gt;&gt; status_code;</span><br><span class="line">    <span class="built_in">string</span> status_message;</span><br><span class="line">    getline(response_stream, status_message);</span><br><span class="line">    <span class="keyword">if</span> (!response_stream || http_version.substr(<span class="number">0</span>, <span class="number">5</span>)!= <span class="string">"HTTP/"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"无效响应\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status_code != <span class="number">200</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"响应返回 status code %d\n"</span>, status_code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取应答头部，遇到空行后停止</span></span><br><span class="line">    boost::asio::read_until(socket, response, <span class="string">"\r\n\r\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示应答头部</span></span><br><span class="line">    <span class="built_in">string</span> header;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (getline(response_stream, header)&amp;&amp; header != <span class="string">"\r"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (header.find(<span class="string">"Content-Length: "</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stringstream</span> stream;</span><br><span class="line">            stream &lt;&lt; header.substr(<span class="number">16</span>);</span><br><span class="line">            stream &gt;&gt; len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> size = response.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// .....do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取数据流，直到文件结束</span></span><br><span class="line">    boost::system::error_code error;</span><br><span class="line">    <span class="keyword">while</span> (boost::asio::read(socket, response, boost::asio::transfer_at_least(<span class="number">1</span>), error))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取应答长度</span></span><br><span class="line">        size = response.size();</span><br><span class="line">        <span class="keyword">if</span> (len != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; size &lt;&lt; <span class="string">" Byte "</span> &lt;&lt; (size * <span class="number">100</span>) / len &lt;&lt; <span class="string">"%\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error != boost::asio::error::eof)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> boost::system::system_error(error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; size &lt;&lt; <span class="string">" Byte 内容已下载完毕."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将streambuf 类型转换为string类型返回</span></span><br><span class="line">    <span class="function">istream <span class="title">is</span><span class="params">(&amp;response)</span></span>;</span><br><span class="line">    is.unsetf(ios_base::skipws);</span><br><span class="line">    <span class="built_in">string</span> sz;</span><br><span class="line">    sz.append(istream_iterator&lt;<span class="keyword">char</span>&gt;(is), istream_iterator&lt;<span class="keyword">char</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回转换后的字符串</span></span><br><span class="line">    <span class="keyword">return</span> sz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Get请求</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">GetRequest</span><span class="params">(<span class="keyword">char</span>* host, <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明Asio基础: io_service（任务调度机）</span></span><br><span class="line">    boost::asio::io_service io_service;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务器终端列表</span></span><br><span class="line">    tcp::<span class="function">resolver <span class="title">resolver</span><span class="params">(io_service)</span></span>;</span><br><span class="line">    tcp::resolver::<span class="function">query <span class="title">query</span><span class="params">(host, <span class="string">"http"</span>)</span></span>;</span><br><span class="line">    tcp::resolver::iterator iter = resolver.resolve(query);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试链接每一个终端，直到成功建立socket链接</span></span><br><span class="line">    tcp::<span class="function">socket <span class="title">socket</span><span class="params">(io_service)</span></span>;</span><br><span class="line">    boost::asio::connnect(socket, iter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建网络头</span></span><br><span class="line">    <span class="comment">// 指定 "Connection: close" 在获取应答后断开链接，确保获取文件全部数据</span></span><br><span class="line">    boost::asio::streambuf request;</span><br><span class="line">    <span class="function">ostream <span class="title">request_stream</span><span class="params">(&amp;request)</span></span>;</span><br><span class="line">    request_stream &lt;&lt; <span class="string">"GET "</span> &lt;&lt; path &lt;&lt; <span class="string">" HTTP/1.1\r\n"</span>;</span><br><span class="line">    request_stream &lt;&lt; <span class="string">"Host: "</span> &lt;&lt; host &lt;&lt; <span class="string">"\r\n"</span>;</span><br><span class="line">    request_stream &lt;&lt; <span class="string">"Accept: */*\r\n"</span>;</span><br><span class="line">    reuqest_stream &lt;&lt; <span class="string">"Connection: close\r\n\r\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送请求</span></span><br><span class="line">    boost::asio::write(socket, request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取应答状态，应答缓冲流streambuf 会自动增长至完成的行</span></span><br><span class="line">    <span class="comment">// 该增长可以在构造缓冲流时通过设置最大值限制</span></span><br><span class="line">    boost::asio::streambuf response;</span><br><span class="line">    boost::asio::read_until(socket, response, <span class="string">"\r\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查应答是否ok</span></span><br><span class="line">    <span class="function">istream <span class="title">response_stream</span><span class="params">(&amp;response)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> http_version;</span><br><span class="line">    response_stream &gt;&gt; http_version;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> status_code;</span><br><span class="line">    response_stream &gt;&gt; status_vode;</span><br><span class="line">    <span class="built_in">string</span> status_message;</span><br><span class="line">    getline(response_stream, status_message);</span><br><span class="line">    <span class="keyword">if</span> (!response_stream || http_version.substr(<span class="number">0</span>, <span class="number">5</span>) != <span class="string">"HTTP/"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"响应无效\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status_code != <span class="number">200</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"响应返回 status code %d\n"</span>, status_code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取应答头部，遇到空行后停止</span></span><br><span class="line">    boost::asio::read_until(socket, response, <span class="string">"\r\n\r\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示应答头部</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> header;</span><br><span class="line">    <span class="keyword">while</span> (getline(response_stream, header) &amp;&amp; header != <span class="string">"\r"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (header.find(<span class="string">"Content-Length: "</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stringstream</span> stream;</span><br><span class="line">            stream &lt;&lt; header.substr(<span class="number">16</span>);</span><br><span class="line">            stream &gt;&gt; len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> size = response.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boost::system::error_code error;    <span class="comment">// 读取错误</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取数据流，直到文件结束</span></span><br><span class="line">    <span class="keyword">while</span> (boost::asio::read(socket, response, boost::asio::transfer_at_least(<span class="number">1</span>), error))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取应答长度</span></span><br><span class="line">        size = response.size();</span><br><span class="line">        <span class="keyword">if</span> (len != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; size &lt;&lt; <span class="string">" Byte "</span> &lt;&lt; (size * <span class="number">100</span>) / len &lt;&lt; <span class="string">"%"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有读到文件尾，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (error != boost::asio::error::eof)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> boost::system::system_error(error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; size &lt;&lt; <span class="string">" Byte 内容已经下载完毕."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将streambuf类型转换为string类型，并返回</span></span><br><span class="line">    <span class="function">istream <span class="title">is</span><span class="params">(&amp;response)</span></span>;</span><br><span class="line">    is.unsetf(ios_base::skipws);</span><br><span class="line">    <span class="built_in">string</span> sz;</span><br><span class="line">    sz.append(istream_iterator&lt;<span class="keyword">char</span>&gt;(is), istream_iterator&lt;<span class="keyword">char</span>&gt;());</span><br><span class="line">    <span class="keyword">return</span> sz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// GET重载</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">GetRequest</span><span class="params">(stirng url)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去掉url中的协议头</span></span><br><span class="line">    <span class="keyword">if</span> (url.find(<span class="string">"http://"</span>) != <span class="built_in">string</span>::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        url = url.substr(<span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"url:%s\n"</span>, url.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 截取host字符串</span></span><br><span class="line">    index = url.find(<span class="string">"/"</span>);</span><br><span class="line">    <span class="keyword">char</span>* host = <span class="keyword">new</span> <span class="keyword">char</span>[index];</span><br><span class="line">    <span class="built_in">strcpy</span>(host, url.substr(<span class="number">0</span>, index).c_str());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 截取urlPath字符串</span></span><br><span class="line">    <span class="keyword">char</span>* urlPath = <span class="keyword">new</span> <span class="keyword">char</span>[url.length() - index + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(urlPath, url.substr(index, url.length() - index).c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> GetRequest(host, urlPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LPCSTR, LPWSTR, PTSTR, LPTSTR的区别</title>
    <url>/2019/12/17/LPCSTR-LPWSTR-PTSTR-LPTSTR%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>转载于 <a href="https://blog.csdn.net/xuruoxin/article/details/21984949" target="_blank" rel="noopener">https://blog.csdn.net/xuruoxin/article/details/21984949</a></p>
<h2 id="先来讲L、P、C、T、STR的意义"><a href="#先来讲L、P、C、T、STR的意义" class="headerlink" title="先来讲L、P、C、T、STR的意义"></a>先来讲L、P、C、T、STR的意义</h2><p><strong>L表示long指针</strong>，这是为了兼容Windows 3.1等16位操作系统遗留下来的，在win32以及其他的32位操作系统中，long和near指针及far修饰符都是为了兼容的作用，没有实际意义。即<strong>win32中，long,near,far指针与普通指针没有区别，LP与P是等效的</strong>。<br><strong>P表示这是一个指针</strong>。<br><strong>T表示_T宏</strong>， 这个宏用来表示你的字符是否使用 UNICODE，如果你的程序定义了UNICODE或者其他相关的宏，那么这个字符或者字符串将被作为UNICODE字符串，否则就是标准的ANSI字符串。<br><strong>STR表示这个变量是一个字符串</strong>。<br><strong>C表示是一个常量，const</strong>。</p>
<p>LPTSTR:<br>如果定义了UNICODE宏则LPTSTR被定义为 LPWSTR。 <code>typedef LPTSTR LPTWSTR;</code><br>否则LPTSTR被定义位LPSTR。   <code>typedef LPTSTR LPSTR;</code></p>
<h2 id="下面列出一些常用的typedefs："><a href="#下面列出一些常用的typedefs：" class="headerlink" title="下面列出一些常用的typedefs："></a>下面列出一些常用的typedefs：</h2><p><strong>类型  MBCS    Unicode</strong><br><code>WCHAR  wchar_t  wchar_t</code><br><code>LPSTR  char*    char*</code><br><code>LPCSTR const char*  const char*</code><br><code>LPWSTR wchar_t*    wchar_t*</code><br><code>LPCWSTR const wchar_t* const wchar_t*</code><br><code>TCHAR  char     wchar_t</code><br><code>LPTSTR TCHAR*(或char*) TCHAR*(或wchar_t*)</code><br><code>LPCTSTR const TCHAR*   const TCHAR*</code></p>
<p>由于Win32 API文档的函数列表使用函数的常用名字（例如，SetWindowText),所有的字符串都适用TCHAR来定义的。（除了XP中引入的只适用于Unicode的API）。所以结论，在VS2005系统中，为提高可移植性，<strong>定义字符串时使用TCHAR，转化为UNICODE时用_T而不用L</strong>。</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>名字查找与类的作用域</title>
    <url>/2019/11/28/%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE%E4%B8%8E%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="名字查找的一般规则"><a href="#名字查找的一般规则" class="headerlink" title="名字查找的一般规则"></a>名字查找的一般规则</h2><p>名字查找（name lookup），即寻找与所用名字最匹配的声明的过程。一般分为三个步骤：</p>
<ol>
<li>首先，在名字所在的块中查找对应的声明语句，<strong>只考虑名字出现之前的声明</strong>。</li>
<li>如果没找到，继续查找外层作用域。</li>
<li>如果最终没有找到匹配的声明，则程序报错。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> nameA = <span class="number">1</span>;	<span class="comment">// 2. 在外层作用域中查找</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (nameA == <span class="number">1</span>)		<span class="comment">// 1. 先在块儿中查找</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类中变量的名字查找"><a href="#类中变量的名字查找" class="headerlink" title="类中变量的名字查找"></a>类中变量的名字查找</h2><p>对于类内部的成员函数来说，查找名字的方式与一般的名字查找方式不同。在类中，定义分两步处理：</p>
<ol>
<li>首先，编译所有成员的声明。</li>
<li>直到类全部可见后才编译函数体。</li>
</ol>
<p><strong>编译器处理完类中的全部声明后才会处理成员函数的定义</strong>。这样做的好处是，成员函数可以使用类中的任何名字。如果成员函数的定义和声明被同时处理，那么就只能在成员函数中使用已经出现过的名字。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中string.erase()的用法，结合string.find()写一个字符串替换函数</title>
    <url>/2019/11/07/C-%E4%B8%ADstring-erase-%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>参考：<a href="https://blog.csdn.net/u010472607/article/details/80431604" target="_blank" rel="noopener">https://blog.csdn.net/u010472607/article/details/80431604</a></p>
<h2 id="erase方法原型"><a href="#erase方法原型" class="headerlink" title="erase方法原型"></a>erase方法原型</h2><ol>
<li><p><strong>basic_string &amp; erase(size_type pos=0, size_type n=npos);</strong></p>
<p>1). <code>string.erase( pos, n );</code>    // 从给定位置 pos 开始，要删除的字符长度为n</p>
<p>2). <code>string.erase( pos );</code>     // 从给定位置 pos开始，删除到结尾结束</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="built_in">std</span>::<span class="built_in">string</span> strSource = <span class="string">"erase test! test"</span>;</span><br><span class="line">  	strSource.erase(<span class="number">11</span>);	<span class="comment">// 从pos等于10开始，删除后面的字符只到结尾</span></span><br><span class="line">  											<span class="comment">// 即 " test"</span></span><br><span class="line">  	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'-'</span> &lt;&lt; strSource &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  	strSource.erase(<span class="number">6</span>, <span class="number">5</span>); <span class="comment">// pos = 6， 删除pos后5个字符</span></span><br><span class="line">  											 <span class="comment">// 即 "test!"</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'-'</span> &lt;&lt; strSource &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p><strong>iterator erase(const_iterator position)</strong></p>
<p>删除迭代器位置处的单个字符，并返回<code>下个元素</code>的迭代器</p>
</li>
<li><p><strong>iterator erase(const_iterator first, const_iterator last)</strong></p>
<p>删除迭代器<code>[first, last)</code>区间的所有字符，返回一个指向被删除的最后一个元素的下一个字符的迭代器。 </p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> strSource = <span class="string">"erase test! test"</span>;</span><br><span class="line">  	strSource.erase(strSource.begin() + <span class="number">11</span>);	<span class="comment">// 删除test前的一个空格</span></span><br><span class="line">  	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'-'</span> &lt;&lt; strSource &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  	strSource.erase(strSource.begin() + <span class="number">11</span>, strSource.end()); <span class="comment">// 删除 " test!" </span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'-'</span> &lt;&lt; strSource &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>除了<code>erase</code>方法用于删除string中的元素，<code>void pop_back();</code>方法也可以用来删除元素，但是只能删除string的最后一个元素</p>
<h2 id="查找方法"><a href="#查找方法" class="headerlink" title="查找方法"></a>查找方法</h2><p>在使用<code>erase</code>删除函数的时候，经常会和查找函数一起使用</p>
<p><code>string.find()</code>方法参数可以是char或者string类型，为待查找的目标，返回值为 size_type; 当查找不到目标是，返回值为 npos。下面我用两个方法结合起来写了一个替换给定字符串中的部分字符串的方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ReplaceString</span><span class="params">(<span class="built_in">string</span> &amp; strSource, <span class="built_in">string</span> strOld, <span class="built_in">string</span> strNew)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> nOldLen = strOld.length();</span><br><span class="line">	<span class="keyword">int</span> nNewLen = strNew.length();</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* pNew = strNew.c_str();</span><br><span class="line">	<span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		idx = strSource.find(strOld, idx);  <span class="comment">// find strOld's idx from strOld[idx]</span></span><br><span class="line">		<span class="keyword">if</span> (idx == <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		strSource.erase(idx, nOldLen);	<span class="comment">// 从idx开始，删除后面的nOldLen个字符</span></span><br><span class="line">		strSource.insert(idx, pNew);</span><br><span class="line">		idx += nNewLen;</span><br><span class="line">		result = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++局部静态对象</title>
    <url>/2019/10/23/C-%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="局部静态对象"><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h1><p>C++局部静态对象的生命周期不受块的约束，在程序的执行路径<strong>第一次经过对象定义语句时初始化</strong>，直到<strong>程序结束才被销毁</strong>。在此期间，即便是变量所在函数结束执行也不会对它产生影响。</p>
<p>以我之前经历作为一个例子，当时是要写一个文件读取函数，读取服务配置信息。如果没读到，就返回一个默认值。如果没有将变量 <code>ret</code>设为局域静态变量，那么我每调用一次GetFileString()，就要重新从文件里读配置信息。如果设置为静态变量，那么不论调用多少次，只要程序没结束，实际上就<strong>只用读一次</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetFileString</span><span class="params">(<span class="built_in">std</span>::sting filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">string</span> ret = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">if</span> (ret.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 读文件字符串赋给ret</span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (ret.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    ret = <span class="string">"default_value"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>线程管理的基础（一）</title>
    <url>/2019/10/18/%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h1><p>线程在<code>std::thread</code>对象创建时启动。最简单的情况下，任务也会很简单，通常时无参数无返回（void-returning）的函数。这些函数在线程上运行，函数运行完，线程就结束了。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>;  <span class="comment">// 无参数无返回的函数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">my_thread</span><span class="params">(function_1)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>同样的，<code>std::thread</code>可以用<strong>可调用(callable)类型</strong>构造，将带有函数调用符类型的实例传入<code>std::thread</code>类中，替换默认的构造函数。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ctask</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        do_something();</span><br><span class="line">        do_something_else();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Ctask f;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">my_thread</span><span class="params">(f)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>代码中，提供的<strong>函数对象会复制到新线程的存储空间中</strong>，函数对象的<code>执行和调用都在线程的内存空间中进行</code>。</p>
<p>同时，当我们传递了一个<strong>临时变量</strong>而不是一个命名的变量时，C++编译器会将其<code>解析为函数声明</code>，而不是类型对象的定义。<br>例如：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">my_thread</span><span class="params">(Ctask())</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这里相当于声明了一个名为<code>my_thread</code>的函数，这个函数带有一个参数（函数指针指向没有参数并返回Ctask对象的函数，返回一个<code>std::thread</code>对象的函数，而非启动了线程。下图是一个示例：</p>
<p>有三种方法可以避免这个问题：</p>
<ol>
<li>在启动线程前先命名好函数对象。</li>
<li>使用多组括号。</li>
<li>使用新的统一化语法。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">my_thread</span><span class="params">( (Ctask()) )</span></span>; <span class="comment">//使用多组括号</span></span><br><span class="line"><span class="built_in">std</span>::thread my_thread&#123; Ctask() &#125;    <span class="comment">//使用新的统一化语法</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="不要在对象销毁后再去分离线程"><a href="#不要在对象销毁后再去分离线程" class="headerlink" title="不要在对象销毁后再去分离线程"></a>不要在对象销毁后再去分离线程</h1><p>在线程启动后，你需要明确接下来是等待线程结束，还是让其自主分离。如果直到<code>std::thread</code>对象销毁之前还没作出决定，程序就会终止(<code>std::thread</code>的析构函数会调用<code>std::terminate()</code>)。因此，即便是有异常存在，也要保证线程能正确的加入(<strong>join</strong>)或分离(<strong>detached</strong>)，且必须要在<code>std::thread</code>对象销毁之前做决定。在<code>std::thread</code>对象销毁之后再去分离它，线程可能会在<code>std::thread</code>对象销毁之后继续运行下去。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> &amp;i;</span><br><span class="line">    func(<span class="keyword">int</span> &amp;_i) : i(_i)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;<span class="number">10000</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            do_something(i);        <span class="comment">//1. 存在潜在隐患：悬空引用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> some_local_state = <span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">my_thread</span><span class="params">(my_func)</span></span>;     </span><br><span class="line">    my_thread.detach();                 <span class="comment">// 2. 不等待线程结束</span></span><br><span class="line">&#125;                                       <span class="comment">// 3. 新线程可能还在运行</span></span><br></pre></td></tr></table></figure></p>
<p>这个例子中，我们让线程自主分离(<code>my_thread.detach()</code>)，所以当<code>main</code>函数执行完成时，新线程中的函数可能还在执行。线程继续执行，它会去调用<code>do_something(i)</code>函数，这时就会<strong>访问已销毁的变量</strong>。就好像在一个单线程程序中，允许一个函数在调用结束后继续持有局部变量的指针和引用。容易出错。</p>
<p>当然我们也有规避的方法：<code>使线程函数的功能齐全，将数据复制到线程中，而非复制到共享数据中</code>。如果使用一个可调用的对象作为线程函数，这个对象就会复制到线程中，而后原始对象就会被销毁。但要小心对象中的<strong>引用和指针</strong>。尽量不要使用一个包含局部变量的函数。</p>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++多线程（一）</title>
    <url>/2019/10/10/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>转载自<a href="https://segmentfault.com/a/1190000016171072?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016171072?utm_source=tag-newest</a></p>
<h1 id="多线程并发（一）"><a href="#多线程并发（一）" class="headerlink" title="多线程并发（一）"></a>多线程并发（一）</h1><h1 id="什么是并发"><a href="#什么是并发" class="headerlink" title="什么是并发"></a>什么是并发</h1><p>对于<strong>单核CPU</strong>，在某个时刻只可能处理一个任务，要想处理另一个任务，只能进行任务切换，看起来任务就像在并行发生。尽管不是在严格的执行多个任务，我们也称其为<strong>并发（concurrency）</strong>。真正的并发是在多核CPU上，能够真正的同时执行多个任务，称谓<strong>硬件并发（hardware concurrency）</strong>。</p>
<p>并发并非没有代价，单核CPU上想要并发执行任务需要付出任务之间切换的时间代价。如下图：</p>
<p><img src="/2019/10/10/C-多线程（一）/01.png" alt="单核CPU并发执行任务"><br>单核的CPU交替执行两个任务，每次执行其中一块，其花费的时间大于按照先后顺序依次执行两个任务。这是因为CPU每次切换执行的任务块儿时需要执行一次<strong>上下文切换</strong>（图中的灰色块）。上下文切换需要操作系统为当前运行的任务保存CPU的状态和指令指针，算出要切换到哪个任务，并为要切换的任务重新加载处理器状态。然后将新任务的指令和数据载入到缓存中。</p>
<h1 id="并发的方式"><a href="#并发的方式" class="headerlink" title="并发的方式"></a>并发的方式</h1><h2 id="多进程并发"><a href="#多进程并发" class="headerlink" title="多进程并发"></a>多进程并发</h2><p>将应用程序分为多个<strong>独立的、单线程</strong>的进程，他们可以同时运行。</p>
<p><img src="/2019/10/10/C-多线程（一）/并发的进程之间的通讯.png" alt="并发的进程之间的通讯"></p>
<p>这些独立的进程可以通过常规的<strong>进程间的通讯机制</strong>进行通讯，如管道、信号、消息队列、共享内存、存储映射I/O、信号量、套接字等等。</p>
<p>缺点：</p>
<ul>
<li>进程间的通讯较为复杂，速度相对线程间的通讯更慢。</li>
<li>启动进程的开销比线程大，使用的系统资源也更多。</li>
</ul>
<p>优点：</p>
<ul>
<li>进程间的通信机制相比线程更加安全。</li>
<li>能够很容易的将一台机器上的多进程程序部署在不同的机器上。</li>
</ul>
<h2 id="多线程并发"><a href="#多线程并发" class="headerlink" title="多线程并发"></a>多线程并发</h2><p>线程很像轻量级的进程，但是一个进程中的所有线程都<strong>共享相同的地址空间</strong>，线程间的大部分数据都可以共享。线程间的通讯一般通过<strong>共享内存</strong>来实现。</p>
<p>优点：</p>
<ul>
<li>由于可以共享数据，多线程间的通信开销比进程小得多。</li>
<li>线程启动的比进程块，占用的资源更少。</li>
</ul>
<p>缺点：</p>
<ul>
<li>共享数据太过灵活，为了维护正确的共享，代码写起来比较复杂。</li>
<li>无法部署在分布式系统上。</li>
</ul>
<h1 id="什么时候不用并发"><a href="#什么时候不用并发" class="headerlink" title="什么时候不用并发"></a>什么时候不用并发</h1><p>基本上，不使用并发的唯一原因就是：<strong>收入比不上成本</strong>。除非潜在的性能增益足够大或关注点分离地足够清晰，能抵消所需的额外的开发时间以及维护多线程代码的相关额外成本。</p>
<ul>
<li><strong>启动线程时需要固定的开销</strong>，如果线程完成的很快，那很划不来。</li>
<li><strong>线程是有限的资源</strong>，运行太多线程可能会耗尽进程的可用内存或地址空间。</li>
<li>运行越多的线程，操作系统就需要做越多的<strong>上下文切换</strong>，开销越大。</li>
</ul>
<h1 id="多线程库简介"><a href="#多线程库简介" class="headerlink" title="多线程库简介"></a>多线程库简介</h1><p>C++11中提供了多线程的标准库，提供了管理线程、保护共享数据、线程间同步操作、原子操作等类。</p>
<p>多线程库对应的头文件是  <code>#include &lt;thread&gt;</code>，类名为<code>std::thread</code>。</p>
<p>一个简单的串行程序如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm function_1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    function_1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个典型的<strong>单进程程序</strong>，任何程序都是一个进程，<code>main()</code>函数就是其中的主线程，单个线程都是顺序执行。</p>
<p>将上面的程序改造成多线程程序其实很简单，让 function_1()函数在另外的线程中执行：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm function_1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(function_1)</span></span>;</span><br><span class="line">    <span class="comment">// do other things</span></span><br><span class="line">    t1.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分析：</p>
<ol>
<li>首先，构建一个<code>std::thread</code>对象<code>t1</code>，构造的时候传递一个参数，这个参数是一个函数，这个函数就是这个线程的<strong>入口函数</strong>，函数执行完了，整个线程也就执行完了。</li>
<li>线程创建成功后，就会<strong>立即启动</strong>，并没有一个类似<code>start</code>的函数来显示的启动线程。</li>
<li>一旦线程开始运行，就需要显示的决定是要等待它完成（join），或者分离它让它自动运行（detach）。注意：只需要在<code>std::thread</code>对象<strong>被销毁之前</strong>作出这个决定。这个例子中，对象<code>t1</code>是栈上变量，在<code>main</code>函数执行结束后就会被销毁，所以需要在<code>main</code>函数结束之前做决定。</li>
<li>这个例子中选择使用了<code>t1.join()</code>，主线程会一直阻塞，知道子线程完成，<code>join()</code>函数的另一个任务是回收该线程中使用的资源。</li>
</ol>
<p><strong>线程对象和对象内部管理的线程的生命周期并不一样</strong>， 如果线程执行的快，可能内部的线程已经结束了，但线程对象还活着，也有可能线程对象已经被析构了，内部的线程还在运行。</p>
<p>假设<code>t1</code>线程是一个执行很慢的线程，主线程并不想等待子线程结束就结束整个任务，直接删掉<code>t1.join()</code>是不行的，程序会被终止（析构<code>t1</code>的时候会调用<code>std::terminate</code>, 程序会打印<code>terminate called without an active exception</code>)。</p>
<p>与之对应，我们可以调用<code>t1.detach()</code>，从而将<code>t1</code>线程放在<strong>后台运行</strong>，所有权和控制权被转交给<code>C++</code>运行时库，以确保与线程相关联的资源在线程退出后能被正确的回收。参考<code>UNIX</code>的<strong>守护进程（daemon process）</strong> 的概念，这种被分离的线程称为<strong>守护线程（daemon threads）</strong>。线程被分离后，及时该线程对象被析构了，线程还是能在后台继续运行，只是由于对象被析构了，主线程不能通过对象名与这个线程进行通信。例如：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 延时500ms 为了保证test()运行结束之后才打印</span></span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">500</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm function_1()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(function_1)</span></span>;</span><br><span class="line">    t1.detach();</span><br><span class="line">    <span class="comment">// t1.join();</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"test() finished"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="comment">// 让主线程晚于子线程结束</span></span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">1000</span>));   <span class="comment">// 延时1s</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用t1.detach()时</span></span><br><span class="line"><span class="comment">// test() finished</span></span><br><span class="line"><span class="comment">// I'm function_1()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用t1.join()时</span></span><br><span class="line"><span class="comment">// I'm function_1()</span></span><br><span class="line"><span class="comment">// test() finished</span></span><br></pre></td></tr></table></figure></p>
<p>分析：</p>
<ol>
<li>由于线程入口函数内部有个<code>500ms</code>的延时，所以在还没有打印的时候，<code>test()</code>已经执行完成了，<code>t1</code>已经被析构了，但是它负责的那个线程还是能够运行，这就是<code>detach()</code>的作用.</li>
<li>如果去掉<code>main</code>函数中的<code>1s</code>延时，会发现<strong>什么都没有打印</strong>，因为主线程执行的太快，整个程序已经结束了，那个后台程序被<code>C++</code>运行时库回收了。</li>
<li>如果将<code>t1.detach()</code>换成<code>t1.join()</code>，<code>test</code>函数会在<code>t1</code>线程执行结束之后，才会执行结束。</li>
</ol>
<p>一旦一个线程被分离了，就不能够再被<code>join</code>了。如果非要调用，程序就会崩溃，可以使用<code>joinable()</code>函数判断一个线程对象时候能调用<code>join()</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(function_1)</span></span>;</span><br><span class="line">    t1.detach();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t1.joinable())</span><br><span class="line">        t1.join();</span><br><span class="line">    </span><br><span class="line">    assert(!t1.joinable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>My First Blog</title>
    <url>/2019/09/13/diy/</url>
    <content><![CDATA[<p>This is my first blog. </p>
<p>Do what I love do.</p>
]]></content>
  </entry>
</search>
